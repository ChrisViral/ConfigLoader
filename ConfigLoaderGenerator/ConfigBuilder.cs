using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using ConfigLoaderGenerator.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/* ConfigLoader is distributed under CC BY-NC-SA 4.0 INTL (https://creativecommons.org/licenses/by-nc-sa/4.0/).                           *\
 * You are free to redistribute, share, adapt, etc. as long as the original author (stupid_chris/Christophe Savard) is properly, clearly, *
\* and explicitly credited, that you do not use this material to a commercial use, and that you distribute it under the same license.     */

namespace ConfigLoaderGenerator;

/// <summary>
/// ConfigNode Load/Save source builder
/// </summary>
/// <param name="syntax">Type syntax node for which to build the source for</param>
/// <param name="type">Type symbol for which to build the source for</param>
/// <param name="data">ConfigObject attribute data</param>
/// <param name="fields">Fields attribute data</param>
public static class ConfigBuilder
{
    /// <summary>
    /// Generated file header
    /// </summary>
    private static readonly SyntaxTrivia GeneratedComment = Comment("// <auto-generated />");

    /// <summary>
    /// Generate the source file for the given template
    /// </summary>
    /// <returns>A tuple containing the generated file name and full file source</returns>
    public static (string fileName, string source) GenerateSource(ConfigData data, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        // Compilation root
        CompilationUnitSyntax root = CompilationUnit();
        HashSet<INamespaceSymbol> usingNamespaces = [];

        // Declare the type we edit
        TypeDeclarationSyntax type = data.Syntax switch
        {
            ClassDeclarationSyntax         => ClassDeclaration(data.Syntax.Identifier),
            StructDeclarationSyntax        => StructDeclaration(data.Syntax.Identifier),
            RecordDeclarationSyntax record => RecordDeclaration(record.ClassOrStructKeyword, record.Identifier),
            _                              => throw new InvalidOperationException($"Invalid generation type kind ({data.Syntax.GetType().Name})")
        };
        type = type.WithModifiers(data.Syntax.Modifiers);

        // Generate methods
        ParameterSyntax nodeParam = Parameter("node".Tokenize()).WithType("ConfigNode".AsIdentifier());
        MethodDeclarationSyntax loadMethod = MethodDeclaration(SyntaxKind.VoidKeyword.Type(), data.Attribute.LoadMethodName.Tokenize())
                                            .AddModifiers(data.Attribute.LoadAccessModifier)
                                            .AddParameterListParameters(nodeParam)
                                            .WithBody(Block());
        MethodDeclarationSyntax saveMethod = MethodDeclaration(SyntaxKind.VoidKeyword.Type(), data.Attribute.SaveMethodName.Tokenize())
                                            .AddModifiers(data.Attribute.SaveAccessModifier)
                                            .AddParameterListParameters(nodeParam)
                                            .WithBody(Block());

        // TODO: Generate method code

        // Add methods to type
        type = type.AddMembers(loadMethod, saveMethod);

        // Add namespace if needed
        MemberDeclarationSyntax topmostDeclaration = type;
        if (data.Type.ContainingNamespace is not null)
        {
            topmostDeclaration = NamespaceDeclaration(data.Type.ContainingNamespace.Name.AsIdentifier()).AddMembers(type);
        }

        // Add usings
        if (usingNamespaces.Count > 0)
        {
            UsingDirectiveSyntax[] usingDirectives = usingNamespaces.OrderBy(u => u, UsingComparer.Comparer)
                                                                    .Select(u => UsingDirective(u.Name.AsIdentifier()))
                                                                    .ToArray();

            // Add header comment
            usingDirectives[0] = usingDirectives[0].WithLeadingTrivia(GeneratedComment);
            root               = root.AddUsings(usingDirectives);
        }
        else
        {
            // Add header comment
            topmostDeclaration = topmostDeclaration.WithLeadingTrivia(GeneratedComment);
        }

        // Add topmost member to root
        root = root.AddMembers(topmostDeclaration);

        // Output
        string lineFeed = CarriageReturnLineFeed.ToFullString();
        root = root.NormalizeWhitespace(eol: lineFeed);
        return ($"{data.Type.Name}.generated.cs", root.ToFullString() + lineFeed);
    }
}
