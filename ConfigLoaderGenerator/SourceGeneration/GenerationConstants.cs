using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using ConfigLoader.Exceptions;
using ConfigLoaderGenerator.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/* ConfigLoader is distributed under CC BY-NC-SA 4.0 INTL (https://creativecommons.org/licenses/by-nc-sa/4.0/).                           *\
 * You are free to redistribute, share, adapt, etc. as long as the original author (stupid_chris/Christophe Savard) is properly, clearly, *
\* and explicitly credited, that you do not use this material to a commercial use, and that you distribute it under the same license.     */

namespace ConfigLoaderGenerator.SourceGeneration;

/// <summary>
/// Global generation constants
/// </summary>
public static class GenerationConstants
{
    #region Supported types
    /// <summary>
    /// C# builtin types
    /// </summary>
    public static readonly HashSet<string> BuiltinTypes =
    [
        typeof(byte).FullName,
        typeof(sbyte).FullName,
        typeof(short).FullName,
        typeof(ushort).FullName,
        typeof(int).FullName,
        typeof(uint).FullName,
        typeof(long).FullName,
        typeof(ulong).FullName,
        typeof(float).FullName,
        typeof(double).FullName,
        typeof(decimal).FullName,
        typeof(bool).FullName,
        typeof(char).FullName,
        typeof(string).FullName
    ];
    /// <summary>
    /// Supported non-builtin types
    /// </summary>
    public static readonly HashSet<string> SupportedTypes =
    [
        typeof(Guid).FullName,
        $"{UnityEngine}.Vector2",
        "Vector2d",
        $"{UnityEngine}.Vector2Int",
        $"{UnityEngine}.Vector3",
        "Vector3d",
        $"{UnityEngine}.Vector3Int",
        $"{UnityEngine}.Vector4",
        $"{UnityEngine}.Vector4d",
        $"{UnityEngine}.Quaternion",
        "QuaternionD",
        $"{UnityEngine}.Rect",
        $"{UnityEngine}.Color",
        $"{UnityEngine}.Color32",
        $"{UnityEngine}.Matrix4x4",
        "Matrix4x4D"
    ];
    /// <summary>
    /// Directly supported <see cref="ICollection{T}"/> types
    /// </summary>
    public static readonly HashSet<string> SupportedCollections =
    [
        typeof(List<>).GetDisplayName(),
        typeof(LinkedList<>).GetDisplayName(),
        typeof(HashSet<>).GetDisplayName(),
        typeof(SortedSet<>).GetDisplayName(),
        typeof(ReadOnlyCollection<>).GetDisplayName(),
        typeof(Queue<>).GetDisplayName(),
        typeof(Stack<>).GetDisplayName()
    ];
    /// <summary>
    /// Directly supported <see cref="IDictionary{TKey,TValue}"/> types
    /// </summary>
    public static readonly HashSet<string> SupportedDictionaries =
    [
        typeof(Dictionary<,>).GetDisplayName(),
        typeof(SortedDictionary<,>).GetDisplayName(),
        typeof(SortedList<,>).GetDisplayName(),
        typeof(ReadOnlyDictionary<,>).GetDisplayName()
    ];
    #endregion

    #region Comments
    /// <summary>
    /// Generated file header
    /// </summary>
    public static readonly SyntaxTrivia GeneratedComment = Comment("// <auto-generated/>");
    /// <summary>
    /// Load method documentation comment
    /// </summary>
    public static readonly SyntaxTrivia[] LoadMethodDoc = SplitMultilineComment(
"""
/// <summary>
/// Auto-generated <see cref="ConfigNode"/> load
/// </summary>
/// <param name="node"><see cref="ConfigNode"/> to load from</param>
""");
    /// <summary>
    /// Save method documentation comment
    /// </summary>
    public static readonly SyntaxTrivia[] SaveMethodDoc = SplitMultilineComment(
"""
/// <summary>
/// Auto-generated <see cref="ConfigNode"/> save
/// </summary>
/// <param name="node"><see cref="ConfigNode"/> to save to</param>
""");
    #endregion

    #region Types
    /// <summary>
    /// UnityEngine namespace
    /// </summary>
    public const string UnityEngine = "UnityEngine";
    /// <summary>
    /// IConfigNode type
    /// </summary>
    /// ReSharper disable once InconsistentNaming
    public static readonly IdentifierNameSyntax IConfigNode = IdentifierName("IConfigNode");
    /// <summary>
    /// ConfigNode type
    /// </summary>
    public static readonly IdentifierNameSyntax ConfigNode = IdentifierName("ConfigNode");
    /// <summary>
    /// ConfigNode.Value type
    /// </summary>
    public static readonly QualifiedNameSyntax ConfigNodeValue = QualifiedName(ConfigNode, IdentifierName("Value"));
    /// <summary>
    /// <see cref="List{T}"/> type
    /// </summary>
    public static readonly IdentifierNameSyntax GenericList = IdentifierName(nameof(System.Collections.Generic.List<int>));
    /// <summary>
    /// <see cref="KeyValuePair{TKey,TValue}"/> type
    /// </summary>
    public static readonly IdentifierNameSyntax GenericKeyValuePair = IdentifierName(nameof(KeyValuePair<int, int>));
    /// <summary>
    /// <see cref="Dictionary{TKey,TValue}"/> type
    /// </summary>
    public static readonly IdentifierNameSyntax GenericDictionary = IdentifierName(nameof(Dictionary<int, int>));
    /// <summary>
    /// Generic <see cref="string"/> <see cref="HashSet{T}"/>
    /// </summary>
    public static readonly GenericNameSyntax HashSetString = nameof(HashSet<string>).AsGenericName(SyntaxKind.StringKeyword.AsType());
    /// <summary>
    /// <see cref="MissingRequiredConfigFieldException"/> type
    /// </summary>
    public static readonly IdentifierNameSyntax MissingException = nameof(MissingRequiredConfigFieldException).AsName();
    /// <summary>
    /// <see cref="CollectionUtils"/> type
    /// </summary>
    public static readonly IdentifierNameSyntax CollectionUtils = nameof(CollectionUtils).AsName();
    #endregion

    #region Methods
    /// <summary>
    /// IConfigNode region
    /// </summary>
    public static readonly SyntaxTrivia InterfaceRegion = PreprocessingMessage("IConfigNode Implementation");
    /// <summary>
    /// IConfigNode Load method name
    /// </summary>
    public static readonly IdentifierNameSyntax Load = IdentifierName("Load");
    /// <summary>
    /// IConfigNode Save method name
    /// </summary>
    public static readonly IdentifierNameSyntax Save = IdentifierName("Save");
    /// <summary>
    /// AddValue method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax AddValue = IdentifierName("AddValue");
    /// <summary>
    /// AddNode method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax AddNode = IdentifierName("AddNode");
    /// <summary>
    /// IsNullOrEmpty method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax IsNullOrEmpty = nameof(string.IsNullOrEmpty).AsName();
    /// <summary>
    /// Add method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax Add = nameof(HashSet<string>.Add).AsName();
    /// <summary>
    /// Clear method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax Clear = nameof(HashSet<string>.Clear).AsName();
    /// <summary>
    /// Contains method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax Contains = nameof(HashSet<string>.Contains).AsName();
    /// <summary>
    /// ToArray method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax ToArray = nameof(System.Collections.Generic.List<int>.ToArray).AsName();
    /// <summary>
    /// FromList method identifier
    /// </summary>
    public static readonly IdentifierNameSyntax FromList = nameof(ConfigLoader.Utils.CollectionUtils.FromList).AsName();
    #endregion

    #region Variables
    /// <summary>
    /// For index variable
    /// </summary>
    public static readonly IdentifierNameSyntax Index  = IdentifierName("i");
    /// <summary>
    /// ConfigNode parameter
    /// </summary>
    public static readonly IdentifierNameSyntax Node   = IdentifierName("node");
    /// <summary>
    /// ConfigNode nodes
    /// </summary>
    public static readonly IdentifierNameSyntax Nodes   = IdentifierName("nodes");
    /// <summary>
    /// ConfigNode node count variable
    /// </summary>
    public static readonly IdentifierNameSyntax NodeCount   = IdentifierName("nodeCount");
    /// <summary>
    /// ConfigNode node count
    /// </summary>
    public static readonly IdentifierNameSyntax CountNodes  = IdentifierName("CountNodes");
    /// <summary>
    /// ConfigNode value
    /// </summary>
    public static readonly IdentifierNameSyntax Value  = IdentifierName("value");
    /// <summary>
    /// ConfigNode values
    /// </summary>
    public static readonly IdentifierNameSyntax Values = IdentifierName("values");
    /// <summary>
    /// ConfigNode value count variable
    /// </summary>
    public static readonly IdentifierNameSyntax ValueCount = IdentifierName("valueCount");
    /// <summary>
    /// ConfigNode value count
    /// </summary>
    public static readonly IdentifierNameSyntax CountValues  = IdentifierName("CountValues");
    /// <summary>
    /// ConfigNode name
    /// </summary>
    public static readonly IdentifierNameSyntax Name   = IdentifierName("name");
    /// <summary>
    /// Required variable
    /// </summary>
    public static readonly IdentifierNameSyntax Required   = IdentifierName("required");
    /// <summary>
    /// <see cref="Array"/> Length identifier
    /// </summary>
    public static readonly IdentifierNameSyntax Length = nameof(Array.Length).AsName();
    /// <summary>
    /// <see cref="HashSet{T}"/> Count identifier
    /// </summary>
    public static readonly IdentifierNameSyntax Count = nameof(HashSet<string>.Count).AsName();
    /// <summary>
    /// <see cref="KeyValuePair{TKey,TValue}"/> Key
    /// </summary>
    public static readonly IdentifierNameSyntax PairKey = nameof(KeyValuePair<int, int>.Key).AsName();
    /// <summary>
    /// <see cref="KeyValuePair{TKey,TValue}"/> Value
    /// </summary>
    public static readonly IdentifierNameSyntax PairValue = nameof(KeyValuePair<int, int>.Value).AsName();
    #endregion

    #region Utility
    /// <summary>
    /// Generates a comment array for a given multiline comment
    /// </summary>
    /// <remarks>
    /// This may look stupid, but it's <i>waaaaaaaay</i> easier to do this than to try to manually build an XML doc comment
    /// </remarks>
    /// <param name="comment">Comment to split</param>
    /// <returns>And array of individual comments replicating the original multiline comment</returns>
    private static SyntaxTrivia[] SplitMultilineComment(string comment)
    {
        return comment.Split('\n').Select(c => Comment(c.Trim())).ToArray();
    }
    #endregion
}
