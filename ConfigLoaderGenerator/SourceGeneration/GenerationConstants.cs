using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/* ConfigLoader is distributed under CC BY-NC-SA 4.0 INTL (https://creativecommons.org/licenses/by-nc-sa/4.0/).                           *\
 * You are free to redistribute, share, adapt, etc. as long as the original author (stupid_chris/Christophe Savard) is properly, clearly, *
\* and explicitly credited, that you do not use this material to a commercial use, and that you distribute it under the same license.     */

namespace ConfigLoaderGenerator.SourceGeneration;

/// <summary>
/// Global generation constants
/// </summary>
public static class GenerationConstants
{
    #region Comments
    /// <summary>
    /// Generated file header
    /// </summary>
    public static readonly SyntaxTrivia GeneratedComment = Comment("// <auto-generated/>");
    /// <summary>
    /// Load method documentation comment
    /// </summary>
    public static readonly SyntaxTrivia[] LoadMethodDoc = SplitMultilineComment(
"""
/// <summary>
/// Auto-generated <see cref="ConfigNode"/> load
/// </summary>
/// <param name="node"><see cref="ConfigNode"/> to load from</param>
""");
    /// <summary>
    /// Save method documentation comment
    /// </summary>
    public static readonly SyntaxTrivia[] SaveMethodDoc = SplitMultilineComment(
"""
/// <summary>
/// Auto-generated <see cref="ConfigNode"/> save
/// </summary>
/// <param name="node"><see cref="ConfigNode"/> to save to</param>
""");
    #endregion

    #region Types
    /// <summary>
    /// UnityEngine namespace
    /// </summary>
    public const string UnityEngine = "UnityEngine";
    /// <summary>
    /// IConfigNode type
    /// </summary>
    /// ReSharper disable once InconsistentNaming
    public static readonly IdentifierNameSyntax IConfigNode = IdentifierName("IConfigNode");
    /// <summary>
    /// ConfigNode type
    /// </summary>
    public static readonly IdentifierNameSyntax ConfigNode = IdentifierName("ConfigNode");
    /// <summary>
    /// ConfigNode.Value type
    /// </summary>
    public static readonly QualifiedNameSyntax ConfigNodeValue = QualifiedName(ConfigNode, IdentifierName("Value"));
    #endregion

    #region Methods
    /// <summary>
    /// IConfigNode region
    /// </summary>
    public static readonly SyntaxTrivia GeneratedRegion = PreprocessingMessage("Auto-generated Save/Load");
    /// <summary>
    /// IConfigNode region
    /// </summary>
    public static readonly SyntaxTrivia InterfaceRegion = PreprocessingMessage("IConfigNode Implementation");
    /// <summary>
    /// IConfigNode Load method name
    /// </summary>
    public static readonly IdentifierNameSyntax ConfigNodeLoad = IdentifierName("Load");
    /// <summary>
    /// IConfigNode Save method name
    /// </summary>
    public static readonly IdentifierNameSyntax ConfigNodeSave = IdentifierName("Save");
    #endregion

    #region Variables
    /// <summary>
    /// For index variable
    /// </summary>
    public static readonly IdentifierNameSyntax Index  = IdentifierName("i");
    /// <summary>
    /// ConfigNode parameter
    /// </summary>
    public static readonly IdentifierNameSyntax Node   = IdentifierName("node");
    /// <summary>
    /// ConfigNode value count
    /// </summary>
    public static readonly IdentifierNameSyntax Count  = IdentifierName("CountValues");
    /// <summary>
    /// ConfigNode value
    /// </summary>
    public static readonly IdentifierNameSyntax Value  = IdentifierName("value");
    /// <summary>
    /// ConfigNode values
    /// </summary>
    public static readonly IdentifierNameSyntax Values = IdentifierName("values");
    /// <summary>
    /// ConfigNode value name
    /// </summary>
    public static readonly IdentifierNameSyntax Name   = IdentifierName("name");
    #endregion

    #region Utility
    /// <summary>
    /// Generates a comment array for a given multiline comment
    /// </summary>
    /// <remarks>
    /// This may look stupid, but it's <i>waaaaaaaay</i> easier to do this than to try to manually build an XML doc comment
    /// </remarks>
    /// <param name="comment">Comment to split</param>
    /// <returns>And array of individual comments replicating the original multiline comment</returns>
    private static SyntaxTrivia[] SplitMultilineComment(string comment)
    {
        return comment.Split('\n').Select(c => Comment(c.Trim())).ToArray();
    }
    #endregion
}
