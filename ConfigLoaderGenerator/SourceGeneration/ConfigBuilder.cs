using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using ConfigLoaderGenerator.Extensions;
using ConfigLoaderGenerator.Metadata;
using ConfigLoaderGenerator.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/* ConfigLoader is distributed under CC BY-NC-SA 4.0 INTL (https://creativecommons.org/licenses/by-nc-sa/4.0/).                           *\
 * You are free to redistribute, share, adapt, etc. as long as the original author (stupid_chris/Christophe Savard) is properly, clearly, *
\* and explicitly credited, that you do not use this material to a commercial use, and that you distribute it under the same license.     */

namespace ConfigLoaderGenerator.SourceGeneration;

/// <summary>
/// <see cref="ConfigBuilder"/> source generation context
/// </summary>
/// <param name="UsedNamespaces">Set of used namespaces</param>
/// <param name="Token">Source generation cancellation token</param>
public readonly record struct ConfigBuilderContext(NamespaceSet UsedNamespaces, CancellationToken Token);

/// <summary>
/// ConfigNode Load/Save source builder
/// </summary>
public static class ConfigBuilder
{
    /// <summary>
    /// Generated file header
    /// </summary>
    private static readonly SyntaxTrivia GeneratedComment = Comment("// <auto-generated />");
    /// <summary>
    /// ConfigNode parameter
    /// </summary>
    public static readonly ValueIdentifier Node = new("node");
    /// <summary>
    /// For index variable
    /// </summary>
    private static readonly ValueIdentifier Index = new("i");
    /// <summary>
    /// ConfigNode value count
    /// </summary>
    private static readonly ValueIdentifier Count = new("CountValues");
    /// <summary>
    /// ConfigNode value
    /// </summary>
    private static readonly ValueIdentifier Value = new("value");
    /// <summary>
    /// ConfigNode values
    /// </summary>
    private static readonly ValueIdentifier Values = new("values");
    /// <summary>
    /// ConfigNode value name
    /// </summary>
    private static readonly ValueIdentifier Name = new("name");
    /// <summary>
    /// ConfigNode type
    /// </summary>
    private static readonly IdentifierNameSyntax ConfigNode = IdentifierName("ConfigNode");
    /// <summary>
    /// ConfigNode.Value type
    /// </summary>
    private static readonly QualifiedNameSyntax ConfigNodeValue = QualifiedName(ConfigNode, IdentifierName("Value"));

    /// <summary>
    /// Generate the source file for the given template
    /// </summary>
    /// <returns>A tuple containing the generated file name and full file source</returns>
    public static (string fileName, string source) GenerateSource(ConfigData data, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        // Compilation root
        CompilationUnitSyntax root = CompilationUnit();
        ConfigBuilderContext context = new([], token);

        // Declare the type we edit
        TypeDeclarationSyntax type = data.Syntax switch
        {
            ClassDeclarationSyntax         => ClassDeclaration(data.Syntax.Identifier),
            StructDeclarationSyntax        => StructDeclaration(data.Syntax.Identifier),
            RecordDeclarationSyntax record => RecordDeclaration(record.ClassOrStructKeyword, record.Identifier),
            _                              => throw new InvalidOperationException($"Invalid generation type kind ({data.Syntax.GetType().Name})")
        };
        type = type.WithModifiers(data.Syntax.Modifiers);

        // Generate methods
        ParameterSyntax nodeParam = Parameter(Node.Token).WithType(ConfigNode);
        MethodDeclarationSyntax loadMethod = MethodDeclaration(SyntaxKind.VoidKeyword.Type(), data.Attribute.LoadMethodName.AsToken())
                                            .AddModifiers(data.Attribute.LoadAccessModifier)
                                            .AddParameterListParameters(nodeParam)
                                            .WithBody(Block());
        MethodDeclarationSyntax saveMethod = MethodDeclaration(SyntaxKind.VoidKeyword.Type(), data.Attribute.SaveMethodName.AsToken())
                                            .AddModifiers(data.Attribute.SaveAccessModifier)
                                            .AddParameterListParameters(nodeParam)
                                            .WithBody(Block());

        // Generate load and save method code
        loadMethod = GenerateLoadMethod(loadMethod, data.Fields, context);
        saveMethod = GenerateSaveMethod(saveMethod, data.Fields, context);

        // Add methods to type
        type = type.AddMembers(loadMethod, saveMethod);

        // Add namespace if needed
        MemberDeclarationSyntax rootDeclaration = type;
        if (data.Type.ContainingNamespace is not null)
        {
            rootDeclaration = NamespaceDeclaration(data.Type.Namespace().AsIdentifier()).AddMembers(type);
        }

        // Add usings
        if (context.UsedNamespaces.Count > 0)
        {
            UsingDirectiveSyntax[] usingDirectives = context.UsedNamespaces.GetUsings().ToArray();

            // Add header comment
            usingDirectives[0] = usingDirectives[0].WithLeadingTrivia(GeneratedComment);
            root = root.AddUsings(usingDirectives);
        }
        else
        {
            // Add header comment
            rootDeclaration = rootDeclaration.WithLeadingTrivia(GeneratedComment);
        }

        // Add topmost member to root
        root = root.AddMembers(rootDeclaration);

        // This should get the EOL string from the user settings
        string lineFeed = CarriageReturnLineFeed.ToFullString();
        root = root.NormalizeWhitespace(eol: lineFeed);
        return ($"{data.Type.FullName()}.generated.cs", root.ToFullString() + lineFeed);
    }

    #region Load
    /// <summary>
    /// Generates a load method for the given type
    /// </summary>
    /// <param name="method">Load method declaration</param>
    /// <param name="fields">List of fields to generate load code for</param>
    /// <param name="context">Generation context</param>
    /// <returns>The edited load method declaration with the load code generated</returns>
    private static MethodDeclarationSyntax GenerateLoadMethod(MethodDeclarationSyntax method, IEnumerable<ConfigFieldMetadata> fields, in ConfigBuilderContext context)
    {
        // node.ValueCount
        ExpressionSyntax valueCount     = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Node.Identifier, Count.Identifier);
        // for (int i = 0; i < node.ValueCount; i++)
        ForStatementSyntax forStatement = GenerateForLoop(Index, valueCount);
        BlockSyntax forBody             = (BlockSyntax)forStatement.Statement;

        // node.values[i]
        ExpressionSyntax nodeValues   = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Node.Identifier, Values.Identifier);
        ExpressionSyntax currentValue = ElementAccessExpression(nodeValues, BracketedArgumentList(SingletonSeparatedList(Argument(Index.Identifier))));
        // ConfigNode.Value value = nodes.value[i];
        VariableDeclaratorSyntax valueVariable     = VariableDeclarator(Value.Token).WithInitializer(EqualsValueClause(currentValue));
        VariableDeclarationSyntax valueDeclaration = VariableDeclaration(ConfigNodeValue).AddVariables(valueVariable);

        // switch (value.name)
        SwitchStatementSyntax nameSwitchStatement = SwitchStatement(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Value.Identifier, Name.Identifier));

        // ReSharper disable once LoopCanBeConvertedToQuery
        foreach (ConfigFieldMetadata field in fields)
        {
            // Add sections for every field
            nameSwitchStatement = nameSwitchStatement.AddSections(GenerateFieldSwitchSection(field, context));
        }

        // Add statements and return
        forBody      = forBody.AddStatements(LocalDeclarationStatement(valueDeclaration), nameSwitchStatement);
        forStatement = forStatement.WithStatement(forBody);
        return method.AddBodyStatements(forStatement);
    }

    /// <summary>
    /// Generate an incrementing for loop from 0 to <paramref name="count"/>
    /// </summary>
    /// <param name="index">Index variable identifier</param>
    /// <param name="count">Count expression</param>
    /// <param name="context">Generation context</param>
    /// <returns>The generated for loop</returns>
    private static ForStatementSyntax GenerateForLoop(ValueIdentifier index, ExpressionSyntax count, in ConfigBuilderContext context)
    {
        // int
        VariableDeclarationSyntax indexDeclaration = VariableDeclaration(SyntaxKind.IntKeyword.Type());
        // i = 0
        ExpressionSyntax indexVariable = AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, Index.Identifier, 0.AsLiteral());
        // i < count
        ExpressionSyntax condition  = BinaryExpression(SyntaxKind.LessThanExpression, index.Identifier, count);
        // i++
        ExpressionSyntax increment = PostfixUnaryExpression(SyntaxKind.PostIncrementExpression, index.Identifier);
        // for (int i = 0; i < count; i++)
        return ForStatement(indexDeclaration, SingletonSeparatedList(indexVariable), condition, SingletonSeparatedList(increment), Block());
    }

    /// <summary>
    /// Generates a switch section for the given field
    /// </summary>
    /// <param name="field">Field to generate the switch section for</param>
    /// <param name="context">Generation context</param>
    /// <returns>The generated switch section</returns>
    private static SwitchSectionSyntax GenerateFieldSwitchSection(ConfigFieldMetadata field, in ConfigBuilderContext context)
    {
        // case "name":
        SwitchLabelSyntax label = CaseSwitchLabel(field.Name.AsLiteral());
        BlockSyntax body = Block();

        // value.value
        ExpressionSyntax value = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Value.Identifier, Value.Identifier);
        // Value parsing implementation
        body = LoadBuilder.GenerateFieldLoad(body, value, field, context);

        // Add break statement, then Create section with label and body
        body = body.AddStatements(BreakStatement());
        return SwitchSection(SingletonList(label), SingletonList<StatementSyntax>(body));
    }
    #endregion

    #region Save
    /// <summary>
    /// Generates a save method for the given type
    /// </summary>
    /// <param name="method">Save method declaration</param>
    /// <param name="fields">List of fields to generate save code for</param>
    /// <param name="context">Generation context</param>
    /// <returns>The edited save method declaration with the save code generated</returns>
    private static MethodDeclarationSyntax GenerateSaveMethod(MethodDeclarationSyntax method, IEnumerable<ConfigFieldMetadata> fields, in ConfigBuilderContext context)
    {
        // ReSharper disable once LoopCanBeConvertedToQuery
        foreach (ConfigFieldMetadata field in fields)
        {
            // Add save for every field
            method = GenerateFieldSave(method, field, context);
        }

        return method;
    }

    /// <summary>
    /// Generates the save code for the given field
    /// </summary>
    /// <param name="method">Save method declaration</param>
    /// <param name="field">Field to generate the save code for</param>
    /// <param name="context">Generation context</param>
    /// <returns>The edited save method declaration with the field save code generated</returns>
    private static MethodDeclarationSyntax GenerateFieldSave(MethodDeclarationSyntax method, in ConfigFieldMetadata field, in ConfigBuilderContext context)
    {
        // Variables
        ExpressionSyntax name = field.Name.AsLiteral();
        ExpressionSyntax value = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), field.FieldName.AsIdentifier());

        // Value saving implementation
        return SaveBuilder.GenerateFieldSave(method, name, value, field, context);
    }
    #endregion
}
