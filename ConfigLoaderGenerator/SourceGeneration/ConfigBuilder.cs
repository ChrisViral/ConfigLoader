using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using ConfigLoaderGenerator.Extensions;
using ConfigLoaderGenerator.Metadata;
using ConfigLoaderGenerator.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

/* ConfigLoader is distributed under CC BY-NC-SA 4.0 INTL (https://creativecommons.org/licenses/by-nc-sa/4.0/).                           *\
 * You are free to redistribute, share, adapt, etc. as long as the original author (stupid_chris/Christophe Savard) is properly, clearly, *
\* and explicitly credited, that you do not use this material to a commercial use, and that you distribute it under the same license.     */

namespace ConfigLoaderGenerator.SourceGeneration;

/// <summary>
/// ConfigNode Load/Save source builder
/// </summary>
public static class ConfigBuilder
{
    /// <summary>
    /// Generated file header
    /// </summary>
    private static readonly SyntaxTrivia GeneratedComment = Comment("// <auto-generated />");
    /// <summary>
    /// ConfigNode parameter
    /// </summary>
    private static readonly ValueIdentifier Node = new("node");
    /// <summary>
    /// For index variable
    /// </summary>
    private static readonly ValueIdentifier Index = new("i");
    /// <summary>
    /// ConfigNode value count
    /// </summary>
    private static readonly ValueIdentifier Count = new("CountValues");
    /// <summary>
    /// ConfigNode value
    /// </summary>
    private static readonly ValueIdentifier Value = new("value");
    /// <summary>
    /// ConfigNode values
    /// </summary>
    private static readonly ValueIdentifier Values = new("values");
    /// <summary>
    /// ConfigNode value name
    /// </summary>
    private static readonly ValueIdentifier Name = new("name");
    /// <summary>
    /// ConfigNode type
    /// </summary>
    private static readonly IdentifierNameSyntax ConfigNode = IdentifierName("ConfigNode");
    /// <summary>
    /// ConfigNode.Value type
    /// </summary>
    private static readonly QualifiedNameSyntax ConfigNodeValue = QualifiedName(ConfigNode, IdentifierName("Value"));

    /// <summary>
    /// Generate the source file for the given template
    /// </summary>
    /// <returns>A tuple containing the generated file name and full file source</returns>
    public static (string fileName, string source) GenerateSource(ConfigData data, CancellationToken token)
    {
        token.ThrowIfCancellationRequested();

        // Compilation root
        CompilationUnitSyntax root = CompilationUnit();
        HashSet<INamespaceSymbol> usedNamespaces = [];

        // Declare the type we edit
        TypeDeclarationSyntax type = data.Syntax switch
        {
            ClassDeclarationSyntax         => ClassDeclaration(data.Syntax.Identifier),
            StructDeclarationSyntax        => StructDeclaration(data.Syntax.Identifier),
            RecordDeclarationSyntax record => RecordDeclaration(record.ClassOrStructKeyword, record.Identifier),
            _                              => throw new InvalidOperationException($"Invalid generation type kind ({data.Syntax.GetType().Name})")
        };
        type = type.WithModifiers(data.Syntax.Modifiers);

        // Generate methods
        ParameterSyntax nodeParam = Parameter(Node.Token).WithType(ConfigNode);
        MethodDeclarationSyntax loadMethod = MethodDeclaration(SyntaxKind.VoidKeyword.Type(), data.Attribute.LoadMethodName.AsToken())
                                            .AddModifiers(data.Attribute.LoadAccessModifier)
                                            .AddParameterListParameters(nodeParam)
                                            .WithBody(Block());
        MethodDeclarationSyntax saveMethod = MethodDeclaration(SyntaxKind.VoidKeyword.Type(), data.Attribute.SaveMethodName.AsToken())
                                            .AddModifiers(data.Attribute.SaveAccessModifier)
                                            .AddParameterListParameters(nodeParam)
                                            .WithBody(Block());

        // Generate load and save method code
        loadMethod = GenerateLoadMethod(loadMethod, data.Fields, usedNamespaces);
        saveMethod = GenerateSaveMethod(saveMethod, data.Fields, usedNamespaces);

        // Add methods to type
        type = type.AddMembers(loadMethod, saveMethod);

        // Add namespace if needed
        MemberDeclarationSyntax parentDeclaration = type;
        if (data.Type.ContainingNamespace is not null)
        {
            parentDeclaration = NamespaceDeclaration(data.Type.Namespace().AsIdentifier()).AddMembers(type);
        }

        // Add usings
        if (usedNamespaces.Count > 0)
        {
            UsingDirectiveSyntax[] usingDirectives = usedNamespaces.OrderBy(u => u, UsingComparer.Comparer)
                                                                    .Select(u => UsingDirective(u.ToDisplayString().AsIdentifier()))
                                                                    .ToArray();

            // Add header comment
            usingDirectives[0] = usingDirectives[0].WithLeadingTrivia(GeneratedComment);
            root = root.AddUsings(usingDirectives);

            // Clear out, no longer needed
            usedNamespaces.Clear();
        }
        else
        {
            // Add header comment
            parentDeclaration = parentDeclaration.WithLeadingTrivia(GeneratedComment);
        }

        // Add topmost member to root
        root = root.AddMembers(parentDeclaration);

        // Output
        string lineFeed = CarriageReturnLineFeed.ToFullString();
        root = root.NormalizeWhitespace(eol: lineFeed);
        return ($"{data.Type.FullName()}.generated.cs", root.ToFullString() + lineFeed);
    }

    #region Load
    /// <summary>
    /// Generates a load method for the given type
    /// </summary>
    /// <param name="method">Method declaration</param>
    /// <param name="fields">List of fields to generate load code for</param>
    /// <param name="usedNamespaces">Used namespaces</param>
    /// <returns>The edited method declaration with the code generated</returns>
    private static MethodDeclarationSyntax GenerateLoadMethod(MethodDeclarationSyntax method, IEnumerable<ConfigFieldMetadata> fields, ISet<INamespaceSymbol> usedNamespaces)
    {
        // node.ValueCount
        ExpressionSyntax valueCount     = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Node.Identifier, Count.Identifier);
        // for (int i = 0; i < node.ValueCount; i++)
        ForStatementSyntax forStatement = GenerateForLoop(Index, valueCount);
        BlockSyntax forBody             = (BlockSyntax)forStatement.Statement;

        // node.values[i]
        ExpressionSyntax nodeValues   = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Node.Identifier, Values.Identifier);
        ExpressionSyntax currentValue = ElementAccessExpression(nodeValues, BracketedArgumentList(SingletonSeparatedList(Argument(Index.Identifier))));
        // ConfigNode.Value value = nodes.value[i];
        VariableDeclaratorSyntax valueVariable     = VariableDeclarator(Value.Token).WithInitializer(EqualsValueClause(currentValue));
        VariableDeclarationSyntax valueDeclaration = VariableDeclaration(ConfigNodeValue).AddVariables(valueVariable);

        // switch (value.name)
        SwitchStatementSyntax nameSwitchStatement = SwitchStatement(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Value.Identifier, Name.Identifier));

        // ReSharper disable once LoopCanBeConvertedToQuery
        foreach (ConfigFieldMetadata field in fields)
        {
            // Add sections for every field
            nameSwitchStatement = nameSwitchStatement.AddSections(GenerateFieldSwitchSection(field, usedNamespaces));
        }

        // Add statements and return
        forBody      = forBody.AddStatements(LocalDeclarationStatement(valueDeclaration), nameSwitchStatement);
        forStatement = forStatement.WithStatement(forBody);
        return method.AddBodyStatements(forStatement);
    }

    /// <summary>
    /// Generate an incrementing for loop from 0 to <paramref name="count"/>
    /// </summary>
    /// <param name="index">Index variable identifier</param>
    /// <param name="count">Count expression</param>
    /// <returns>The generated for loop</returns>
    private static ForStatementSyntax GenerateForLoop(ValueIdentifier index, ExpressionSyntax count)
    {
        // int i
        VariableDeclarationSyntax indexDeclaration = VariableDeclaration(SyntaxKind.IntKeyword.Type());
        // i = 0
        ExpressionSyntax indexVariable = AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, Index.Identifier, 0.ToLiteral());
        // i < count
        ExpressionSyntax condition  = BinaryExpression(SyntaxKind.LessThanExpression, index.Identifier, count);
        // i++
        ExpressionSyntax increment = PostfixUnaryExpression(SyntaxKind.PostIncrementExpression, index.Identifier);
        // for (int i = 0; i < count; i++)
        return ForStatement(indexDeclaration, SingletonSeparatedList(indexVariable), condition, SingletonSeparatedList(increment), Block());
    }

    /// <summary>
    /// Generates a switch section for the given field
    /// </summary>
    /// <param name="field">Field to generate the switch section for</param>
    /// <param name="usedNamespaces">Used namespaces set</param>
    /// <returns>The generated switch section</returns>
    private static SwitchSectionSyntax GenerateFieldSwitchSection(ConfigFieldMetadata field, ISet<INamespaceSymbol> usedNamespaces)
    {
        // case "name":
        SwitchLabelSyntax label = CaseSwitchLabel(field.Name.ToLiteral());
        BlockSyntax body = Block();

        // value.value
        ExpressionSyntax value = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Value.Identifier, Value.Identifier);
        // Value parsing implementation
        body = LoadBuilder.GenerateFieldLoad(body, value, field, usedNamespaces);

        // Add break statement, then Create section with label and body
        body = body.AddStatements(BreakStatement());
        return SwitchSection(SingletonList(label), SingletonList<StatementSyntax>(body));
    }
    #endregion

    #region Save
    private static MethodDeclarationSyntax GenerateSaveMethod(MethodDeclarationSyntax method, IEnumerable<ConfigFieldMetadata> fields, ISet<INamespaceSymbol> usedNamespaces)
    {
        // ReSharper disable once LoopCanBeConvertedToQuery
        foreach (ConfigFieldMetadata field in fields)
        {
            method = GenerateFieldSave(method, field, usedNamespaces);
        }

        return method;
    }

    private static MethodDeclarationSyntax GenerateFieldSave(MethodDeclarationSyntax method, ConfigFieldMetadata field, ISet<INamespaceSymbol> usedNamespaces)
    {
        // Variables
        ArgumentSyntax nameArgument = Argument(field.Name.ToLiteral());
        ArgumentSyntax member       = Argument(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), field.FieldName.AsIdentifier()));
        ExpressionSyntax addValue   = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, Node.Identifier, "AddValue".AsIdentifier());

        // node.AddValue("value", this.value);
        ExpressionSyntax addValueInvocation = InvocationExpression(addValue).AddArgumentListArguments(nameArgument, member);

        // Add statements to method body
        method = method.AddBodyStatements(ExpressionStatement(addValueInvocation));
        return method;
    }
    #endregion
}
